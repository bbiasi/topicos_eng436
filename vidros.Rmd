---
title: "Modelos Multiclasse - Classificação de Vidros para Análise Forense"
author: "Brenner Silva e Marcello Pessoa"
date: "05/12/2019"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

<style>
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
body {
text-align: justify}
p {line-height: 2em;}
</style>


```{r settings, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE,
                      tidy = TRUE,
                      fig.width = 14,
                      fig.height = 9,
                      out.width  = "1026",
                      out.height = "528",
                      fig.align = "center")
```


```{r pressure, echo=FALSE, fig.cap="A caption", out.width = '100%', fig.cap=''}
# informe!!!
# caso desejado executar o script, e necessario haver internet disponivel tendo
# em vista o download da imagem abaixo!

cover_url = 'https://i.imgur.com/xVOrqDf.png'
if (!file.exists(cover_file <- 'cover.jpg'))
  download.file(cover_url, cover_file, mode = 'wb')
knitr::include_graphics(if (identical(knitr:::pandoc_to(), 'html')) cover_url else cover_file)
```

## APRESENTAÇÃO

<p style="text-align: justify">

**Universidade Federal da Bahia - UFBA**
\
**[Escola Politécnica](http://www.eng.ufba.br/)**
\
**Programa de Pós-Graduação em Engenharia Industrial - [PEI/UFBA](http://www.pei.ufba.br/)**
\
**Departamento de Engenharia Química - DEQ**
\
**ENG436 - Tópicos Especiais em Engenharia**
\
 
\
O presente trabalho foi desenvolvido como parte de avaliação para a disciplina Tópicos Especiais em Engenharia, ministrada pela docente Karla Esquerre da Escola Politécnica da UFBA.
\
O código completo deste arquivo .Rmd pode ser acessado através deste [**link**](•	https://github.com/bbiasi/topicos_eng436).
\

</p>

***

## DESENVOLVIMENTO

<p style="text-align: justify">

Vestígios deixados na cena de um crime podem ser de extrema importância para a resolução do mesmo. Utilizando dos conhecimentos que envolvem o aprendizado de máquina, é possível construir modelos preditivos que deem suporte as análises e obter importantes informações sobre padrões de banco de dados criminológicos. 
\
Diferentes estudos utilizam algoritmos de aprendizado de máquina para tarefas de classificação, procurando otimizar os modelos com variadas técnicas. No presente trabalho fora proposto um modelo preditivo de classificação de vidro multiclasse, utilizando do algoritmo de Random Forest para diferentes cenários de variáveis e técnicas de balanceamento de classes.
\

</p>


## DATASET E CODE {.tabset .tabset-fade}

<p style="text-align: justify">

O presente [*dataset*](https://github.com/bbiasi/topicos_eng436/blob/master/glass.xlsx) em análise é um conjunto de objetos de identificação de vidro da UC Irvine Machine Learning Repository, disponível no [Kaggle](https://www.kaggle.com/uciml/glass), contendo 10 atributos, sendo a resposta o tipo do vidro (*label* / rótulo). 
\
Os atributos em análise são:
\

* 01- RI: Índice de Refração;

* 02- Na: Sódio (medição unitária: porcentagem em peso no óxido correspondente, como são os atributos 03-09);

* 03- Mg: Magnésio;

* 04- Al: Alumínio;

* 05- Si: Silício;

* 06- K: Potássio;

* 07- Ca: Cálcio;

* 08- Ba: Bário;

* 09- Fe: Ferro;

* 10- Tipo de Vidro;

  + X1 - Vidro *float* de construções;
  
  + X2 - Vidro "não" *float* de construções;
  
  + X3 - Vidro *float* de veículos;
  
  + X5 - Vidro de contêineres;
  
  + X6 - Utensílios de mesa (prato, xícara, etc);
  
  + X7 - [*headlamps*](https://www.google.com/search?q=headlamps&rlz=1C1ASUT_pt-BRBR683BR683&sxsrf=ACYBGNTmAvcoSNgIaLA95Js1S3mU0QBewQ:1575247410575&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjsu9zy3ZXmAhXMo1kKHQItBEQQ_AUoAnoECA0QBA&biw=1366&bih=657).
  
\

Abaixo, iniciamos o código indicando o caminho da pasta de trabalho, carregando os pacotes demandados e o *dataset* a ser analisado. O uso do pacote `pacman` foi idealizado em facilitar a reprodutibilidade, dinamicidade de instalação e carregamento de pacotes. Especificamente o pacote `gg3D` demanda que o *download* seja realizado diretamente do **git**, e para tal, utilizamos o pacote `remotes`.
\

</p>


```{r message=FALSE, warning=FALSE}
# setwd("D:/PEI/Doc/Disciplinas/Topicos/topicos_eng436")
# setwd("C:/Users/MARCELLO/Desktop/ENG436/topicos_eng436")

{
  if (!require("pacman")) install.packages("pacman")
  
  pacman::p_load(dplyr, readxl, ggplot2, GGally, skimr, 
                 plotly, knitr, tidyr, shiny, caret, randomForest, 
                 reshape2, tibble, rmdformats, cowplot,
                 car, bestNormalize, forcats, ggQC, scales, lemon)
  
  if (!require("gg3D")) remotes::install_github("AckerDWM/gg3D")
  library(gg3D)
}

# Tema
tema <- theme_bw() +
  theme(axis.title   = element_text(color = "black", size = 18, face = "bold"),
        axis.text.x  = element_text(color = "black", size = 16, face = "bold"),
        axis.text.y  = element_text(color = "black", size = 16, face = "bold"),
        legend.text  = element_text(color = "black", size = 12, face = "bold"),
        legend.title = element_text(color = "black", size = 14, face = "bold"),
        plot.title   = element_text(color = "black", size = 18, face = "bold"))

set.seed(42)
dataset <- readxl::read_excel("glass.xlsx")
```

<p style="text-align: justify">

O primeiro passo para qualquer estruturação ou análise, é o conhecimento acerca da estrutura inicial dos dados. Para tanto, utilizaremos a função `glimpse` do pacote `dplyr`.
\

</p>

```{r, message=FALSE, warning=FALSE}
dplyr::glimpse(dataset)
```

<p style="text-align: justify">

Podemos observar que apenas a variável preditora **RI** está como *dbl* (*double*). Deste modo, transformaremos as *chr* (*character*) para números, tendo em vista a necessidade para exploração descritiva e construção de modelos. A variável *Type* é o *label* (rótulo) de nossas classes de vidro, e essas deverão passar a ser fatores, sendo renomeada para *Tipo*.
\
A variável *RI* será dividida por $10^5$ para adequação de escala real.


</p>

```{r, message=FALSE, warning=FALSE}
df <- dataset %>% 
  dplyr::mutate_if(is.character, as.numeric) %>% 
  dplyr::mutate(Tipo = as.factor(Type),
                RI = RI/(10^5)) %>% 
  dplyr::select(-Type)
df_x <- df

levels(df$Tipo) <- make.names(levels(factor(df$Tipo)))
dplyr::glimpse(df)
```


<p style="text-align: justify">

Com o ajuste inicial do nosso `df`, foi modificado a classe das variáveis nos objetos  e ajustado os fatores / classes / labels / rótulos dos vidros, sendo estes renomeadas para ${X1,\;X2,\;X3,\;X5, X6\;e\;X7}$, para posterior uso na construção de modelo preditivo.
\
Agora vamos analisar se há `NA` ou `NaN` nos nossos dados, e, vamos aproveitar para calcular as estatísticas de tendência central e realizar de modo simultâneo um histograma de nossas variáveis de interesse.
\
Abaixo, utilizaremos as abas `Análise 1` e `Análise 2` para expor nossas informações descritas até aqui. Sendo que a aba `Análise 2`, servirá para nos aprofundarmos na análise descritiva com as variáveis de interesse de acordo com o label.
\

</p>

### Análise 1.1 

```{r, message=FALSE, warning=FALSE, fig.align='center'}
df %>%
  dplyr::select(-c("Tipo")) %>%
  skimr::skim() %>%
  dplyr::rename("Tipo da Variável" = skim_type, "Variável" = skim_variable, "nº NA" = n_missing,
                "Média"  = numeric.mean, "DP" = numeric.sd,
                "p0" = numeric.p0, "p25" = numeric.p25, "p50" =	numeric.p50,
                "p75" = numeric.p75,"p100" = numeric.p100,
                "Histograma" =	numeric.hist) %>%
  dplyr::select(-c("complete_rate")) %>%
  knitr::kable()

plotx <- df %>%
  dplyr::mutate_at(1:9, funs(scale)) %>%
  tidyr::gather("Var", "Valor",-Tipo) %>%
  ggplot2::ggplot() +
  geom_jitter(aes(x = Var, y = Valor, col = Tipo), alpha = 0.6, width = 0.15) +
  guides(colour = guide_legend(override.aes = list(size = 5))) +
  xlab("Variáveis") +
  ylab("z-score") +
  theme_bw() +
  tema +
  theme(legend.position = "bottom")

plotx1 <- df %>%
  dplyr::mutate_at(1:9, funs(scale)) %>%
  tidyr::gather("Var", "Valor",-Tipo) %>%
  ggplot2::ggplot() +
  geom_boxplot(aes(x = Var, y = Valor),
               alpha = 0.9, show.legend = F, width = 0.4) +
  xlab("Variáveis") +
  ylab("z-score") +
  theme_bw()  +
  tema
plotx8 <- cowplot::plot_grid(plotx, plotx1, align = "hv", axis = "bt", labels = c("(A)", "(B)"))

ggsave(file = "plotx8.png", plotx8, width  = 13, height = 9, dpi = 700)
plotx8

#
#
plotx <- df %>%
  dplyr::mutate_at(1:9, funs(scale)) %>%
  tidyr::gather("Var", "Valor",-Tipo) %>%
  ggplot2::ggplot(aes(x = Var, y = Valor)) +
  stat_boxplot(geom ='errorbar', width = 0.2, size = 1) +
  geom_jitter(aes(fill = Tipo), alpha = 0.3, width = 0.2, shape = 21, size = 3) +
  facet_wrap(~Tipo) +
  scale_fill_manual(values = scales::hue_pal()(6)) +
  guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) +
  xlab("Variáveis") +
  ylab("z-score") +
  theme_bw() +
  tema +
  theme(legend.position = "bottom", 
        axis.text.x = element_text(angle = 90))

cores <- c(scales::hue_pal()(6)[2],
           scales::hue_pal()(6)[1],
           scales::hue_pal()(6)[6],
           scales::hue_pal()(6)[3],
           scales::hue_pal()(6)[4],
           scales::hue_pal()(6)[5])


plotx1 <- df %>% 
  dplyr::count(Tipo) %>% 
  ggplot2::ggplot(aes(x = Tipo, y = n)) +
  ggQC::stat_pareto(point.color = "red",
                    point.size = 3,
                    line.color = "black",
                    bars.fill = cores) +
  ggplot2::scale_y_continuous(sec.axis = ggplot2::sec_axis(~./(max(.)*.95)*100,
                                                           name = "% Acumulado de Objetos")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  xlab("Tipo") +
  ylab("Quantidade de Objetos") +
  theme_bw()  +
  tema

plotx8 <- cowplot::plot_grid(plotx, plotx1, align = "hv", axis = "bt", labels = c("(A)", "(B)"))

ggsave(file = "plotx8_2.png", plotx8, width  = 13, height = 9, dpi = 700)
plotx8
```

### Análise 1.2

```{r, message=FALSE, warning=FALSE, fig.align='center'}
# df %>% 
#   dplyr::filter(Tipo == "X6") %>% 
#   dplyr::select(Fe, Ba)
df %>%
  dplyr::group_by(Tipo) %>%
  skimr::skim() %>%
  dplyr::rename("Variável" = skim_variable, "Classe" = Tipo,
                "Média"  = numeric.mean, "DP" = numeric.sd,
                "p0" = numeric.p0, "p25" = numeric.p25, "p50" =	numeric.p50,
                "p75" = numeric.p75,"p100" = numeric.p100,
                "Histograma" =	numeric.hist) %>%
  dplyr::select(-c("skim_type", "complete_rate", "n_missing")) %>%
  knitr::kable()
```

##

***

<p style="text-align: justify">

Como pode-se perceber não temos `NA` ou `NaN` no nosso `df`. Logo, não temos a necessidade de inputar dados faltantes.
\
Nossas variáveis não apresentam distribuições claramente semelhantes. Do ponto de vista descritivo, comparando classes numa mesma variável, a classe **X3** apresenta menor valor médio de **RI**, e **X5** e **X6** apresentam os maiores valores. E, de modo inverso, **X5** e **X6** apresentam os menores valores de desvio padrão (DP), e **X3** apresenta o maior valor.
\
Da variável **Na** os maiores valores de média e DP são referentes a **X6**, e para **X1** e **X3** os valores de média e DP estão próximos. Os valores de DP de **X1** e **X3** para **Mg**, estão muito abaixo que para as outras classes, e os valores de média estão próximos.
\
**X1** e **X2** apresentam baixos valores de DP em **Al**. Em **K**, **X6** apresenta média e DP iguais a zero, e **X5** apresenta elevado DP. Em **Ca**, as médias de **X1** e **X3** são muito próximas, e ambas as classes tem baixo valor de DP. E, para **Ba** e **Fe**, a média e o DP de **X6** são iguais a zero.
\
Contudo é interessante frisar a semelhança entre os dados das classes **X1** e **X3**, apresentando uma leve divergência apenas para **RI** e **Ba**.
\

</p>


```{r, message=FALSE, warning=FALSE, fig.align='center'}
plotx <- df %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))
shiny::div(plotly::ggplotly(plotx), align = "center")

plotx <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))
shiny::div(plotly::ggplotly(plotx), align = "center")
```

<p style="text-align: justify">

Aparentemente não é possível visualizar um padrão claro entre as classes, e através da nossa matriz de dispersão, não conseguimos identificar situação de colinearidade entre as variáveis.
\
A homogeneidade entre os objetos pode, desde já, nos nortear quanto a dificuldade de construção de modelo preditivo com bons valores de sensibilidade e especificidade. E se focarmos nos grupos **X1** e **X3**, que é este, que desde a estatística básica apresenta homogeneidade, poderemos notar o quão similares os grupos são.
\

</p>

### Verificando Especificidades em X1 e X3 {.tabset .tabset-fade}

<p style="text-align: justify">

Os conjuntos de objetos pertencentes a **X1** e **X3** apresentam comportamento muito semelhante, e, em algum casos, com apresentando comportamento similar a uma situação bimodal, e para essas, realizaremos nosso `ggpairs` de formas separadas, dada as devidas condições anunciadas nas abas, e também utilizaremos o recurso de representação em 3D, a fim de tentar melhorar a perspectiva visual.
\

</p>

#### RI > 1 

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plotx <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                RI > 1) %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))

# https://stackoverflow.com/a/34743555/9699371
for(i in 1:plotx$nrow) {
  for(j in 1:plotx$ncol){
    plotx[i,j] <- plotx[i,j] + 
      scale_fill_manual(values = c(scales::hue_pal()(6)[1],
                                   scales::hue_pal()(6)[3])) +
      scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                      scales::hue_pal()(6)[3])) 
  }
}

shiny::div(plotly::ggplotly(plotx), align = "center")
```

#### RI < 1

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plotx <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                RI < 1) %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))
for(i in 1:plotx$nrow) {
  for(j in 1:plotx$ncol){
    plotx[i,j] <- plotx[i,j] + 
      scale_fill_manual(values = c(scales::hue_pal()(6)[1],
                                   scales::hue_pal()(6)[3])) +
      scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                      scales::hue_pal()(6)[3])) 
  }
}
shiny::div(plotly::ggplotly(plotx), align = "center")
```

#### K > 0.4

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plotx <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                K > 0.4) %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))
for(i in 1:plotx$nrow) {
  for(j in 1:plotx$ncol){
    plotx[i,j] <- plotx[i,j] + 
      scale_fill_manual(values = c(scales::hue_pal()(6)[1],
                                   scales::hue_pal()(6)[3])) +
      scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                      scales::hue_pal()(6)[3])) 
  }
}
shiny::div(plotly::ggplotly(plotx), align = "center")
```

#### K < 0.4

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plotx <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                K < 0.4) %>%
  GGally::ggpairs(columns = 1:9,
                  mapping = aes(color = Tipo, alpha = 0.5),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))
for(i in 1:plotx$nrow) {
  for(j in 1:plotx$ncol){
    plotx[i,j] <- plotx[i,j] + 
      scale_fill_manual(values = c(scales::hue_pal()(6)[1],
                                   scales::hue_pal()(6)[3])) +
      scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                      scales::hue_pal()(6)[3])) 
  }
}
shiny::div(plotly::ggplotly(plotx), align = "center")
```

#### Ca versus Mg, Na

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plot_b <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                K < 0.4) %>%
  ggplot2::ggplot() +
  geom_point(aes(x = Ca, y = Na, col = Tipo), size = 7, alpha = 0.5) +
  scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                scales::hue_pal()(6)[3])) + 
  theme_bw() +
  tema +
  theme(legend.position = "bottom")

plot_b1 <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3"),
                K < 0.4) %>%
  ggplot2::ggplot() +
  geom_point(aes(x = Ca, y = Mg, col = Tipo), size = 7, alpha = 0.5) +
  scale_color_manual(values = c(scales::hue_pal()(6)[1],
                                scales::hue_pal()(6)[3])) + 
  theme_bw() +
  tema +
  theme(legend.position = "bottom")
plotb <- cowplot::plot_grid(plot_b, plot_b1, align = "hv")
ggsave(file = "plotb.png", plotb, width  = 11, height = 7, dpi = 700)
plotb
```

#### 3D

```{r, message=FALSE, warning=FALSE, fig.align='center'}
plot1 <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  ggplot(aes(x = Fe, y = RI, z = K,
             color = Tipo)) +
  theme_void() +
  theme(plot.background = element_rect(color = "black")) +
  axes_3D(theta = 0) +
  stat_3D(theta = 0)

plot2 <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  ggplot(aes(x = Fe, y = RI, z = K,
             color = Tipo)) +
  theme_void() +
  theme(plot.background = element_rect(color = "black")) +
  axes_3D(theta = 90) +
  stat_3D(theta = 90)

plot3 <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  ggplot(aes(x = Fe, y = RI, z = K,
             color = Tipo)) +
  theme_void() +
  theme(plot.background = element_rect(color = "black")) +
  axes_3D(theta = 180) +
  stat_3D(theta = 180)

plot4 <- df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  ggplot(aes(x = Fe, y = RI, z = K,
             color = Tipo)) +
  theme_void() +
  theme(plot.background = element_rect(color = "black")) +
  axes_3D(theta = 270) +
  stat_3D(theta = 270)

plotx7 <- cowplot::plot_grid(plot1, plot2, plot3, plot4, align = "hv",
                   labels = c('0°', '90°', '180°', '270°'))
ggsave(file = "plotx7.png", plotx7, width  = 13, height = 9, dpi = 700)
plotx7
```

#### 3D interactive

```{r, message=FALSE, warning=FALSE, cache = TRUE, fig.align='center'}
cores <- c("royalblue1", "darkcyan", "green1", "black", "goldenrod3", "red2")

df %>%
  plotly::plot_ly(x = ~RI, y = ~Ca, z = ~Fe, color = ~Tipo,
                colors = cores, opacity = 0.4, stroke = "black") %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'RI'),
                      yaxis = list(title = 'Ca'),
                      zaxis = list(title = 'Fe')))
df %>%
  plotly::plot_ly(x = ~Al, y = ~Mg, z = ~Fe, color = ~Tipo,
                colors = cores, opacity = 0.4, stroke = "black") %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'Al'),
                      yaxis = list(title = 'Mg'),
                      zaxis = list(title = 'Fe')))
```

#### 3D interactive para X1 e X3

```{r, message=FALSE, warning=FALSE, cache = TRUE, fig.align='center'}
df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  plotly::plot_ly(x = ~RI, y = ~Ca, z = ~Fe, color = ~Tipo,
                colors = cores, opacity = 0.4, stroke = "black") %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'RI'),
                      yaxis = list(title = 'Ca'),
                      zaxis = list(title = 'Fe')))
df %>%
  dplyr::filter(Tipo %in% c("X1", "X3")) %>%
  plotly::plot_ly(x = ~Al, y = ~Mg, z = ~Fe, color = ~Tipo,
                colors = cores, opacity = 0.4, stroke = "black") %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'Al'),
                      yaxis = list(title = 'Mg'),
                      zaxis = list(title = 'Fe')))
```

###

***

<p style="text-align: justify">

Através da análise visual dos gráficos de dispersão é notável que alguns pontos mais distantes da massa de dados. E, apesar do problema em análise abordar variáveis com baixa incerteza de medição e elucidarem grandezas físico-química, realizaremos análise visual para discriminação de potenciais valores aberrantes (*outliers*).
\
Tal fato será importante, também, para tentar minimizar o possível *bias* gerado futuramento no modelo preditor, pois, é nítido que as classes (*labels*) estão desbalanceados, como pode ser visualizado abaixo, onde, de `r nrow(df)` objetos, apenas `r paste0(round(length(which(df$Tipo == "X6"))/nrow(df)*100, 2), "%")` representam a classe **X6**.
\
Contudo, a priori, procederemos com cautela pois **X3** e **X5** também apresentam baixos percentuais de representação no conjunto de objetos em análise, como pode ser visualizado no chunk abaixo. E, no próximo tópico, tentaremos refinar o nosso `df` identificando possíveis *outliers*.
\

</p>


```{r, message=FALSE, warning=FALSE, cache = TRUE, fig.align='center'}
table(df$Tipo)
```

### Outliers

<p style="text-align: justify">

Para iniciar o processo de identificação de possíveis *outliers*, criaremos uma coluna de `ID` no nosso `df` para poder facilitar o processo de manipulação de dados. 
\
Novamente, com o auxílio do gráfico de dispersão, iniciaremos a prospecção dos possíveis objetos enquadrados como *outliers*. E, utilizaremos a ferramenta de gráfico interativo para poder identificar as informações de variáveis e de `ID`.
\

</p>


```{r, message=FALSE, warning=FALSE, fig.align='center'}
df_out <- df %>% 
  tibble::rowid_to_column()

plotx6 <- df_out %>%
  GGally::ggpairs(columns = 2:10,
                  mapping = aes(color = Tipo, alpha = 0.5, ),
                  upper = list(continuous = wrap("cor", size = 2.5)),
                  lower = list(continuous = wrap("points", alpha = 0.3)))

ggsave(file = "plotx6.png", plotx6, width  = 13, height = 9, dpi = 700)
shiny::div(plotly::ggplotly(plotx6),
           align = "center")
```

<p style="text-align: justify">

Foi notado que os objetos $107,\;108,\;164,\;173\;e\;175$ estão muito afastados da massa central de dados. Como pode ser evidenciado abaixo. Sendo $107\;e\;108$ pertencentes a classe **X2** e $164,\;173\;e\;175$ a classe **X5**.
\
A fim de tornar ainda mais evidente a informação, apresentaremos os gráficos de dispersão em maior tamanho e em escala *z-score*.
\

</p>

```{r, message=FALSE, warning=FALSE, fig.align='center'}
df_out2 <- df_out %>% 
  dplyr::mutate(rowid = as.factor(rowid),
                Out = ifelse(rowid == "107" | rowid == "108" | rowid == "164" |
                               rowid == "173" | rowid == "175", "out", "ok")) %>% 
  dplyr::mutate_at(vars(2:10), funs(scale)) %>% # scale()
  tidyr::gather(key = "Variaveis", value = "valor", 2:10)

plotx5 <- df_out2 %>%
  dplyr::mutate(rowid = as.numeric(as.character(rowid))) %>%
  ggplot2::ggplot() +
  ggplot2::geom_jitter(aes(x = Variaveis, y = valor, fill = Out,
                          shape = Out),
                       alpha = 0.5, size = 3,
                       show.legend = F) +
  facet_wrap(~Tipo, scales = "free") +
  scale_shape_manual(values = c(20, 21)) +
  theme_bw()

ggsave(file = "plotx5.png", plotx5, width  = 13, height = 9, dpi = 700)
shiny::div(plotly::ggplotly(plotx5),
           align = "center")

df_out2xx <- df_out2 %>% 
  dplyr::mutate(Out = as.factor(Out))
levels(df_out2xx$Out) <- c('"Normal"', '"Outlier"')
plotx4 <- df_out2xx %>%
  dplyr::filter(Variaveis == "Na") %>%
  ggplot2::ggplot() +
  stat_boxplot(aes(x = Tipo, y = valor),
               geom = "errorbar", width = 0.5) +
  geom_boxplot(aes(x = Tipo, y = valor),
               color = "black", show.legend = F, outlier.shape = NA) +
  geom_point(aes(x = Tipo, y = valor,
                 shape = Out, fill = Out, alpha = Out),
             size = 5, width = 0.2, 
             position = position_jitter(w = 0.1, h = 0)) +
  scale_shape_manual(values = c(24, 21)) +
  scale_alpha_manual(values = c(0.2, 0.7)) +
  scale_y_continuous(limits = c(min(df_out2$valor), max(df_out2$valor))) +
  xlab(label = "Tipo do Vidro") + ylab("Z-Score") +
  theme_bw() + 
  tema + theme(legend.position = "bottom")
plotx4
ggsave(file = "plotx4.png", plotx4, width  = 11, height = 7, dpi = 700)
shiny::div(plotly::ggplotly(plotx4),
           align = "center")
```

<p style="text-align: justify">

Contudo, ao plotar os pontos e box-plot em função da variável **Na**, podemos notar que os objetos $173\;e\;175$ não apresentam comportamento incomum ou valor aberrante para o parâmetro, logo, manteremos como *outliers* apenas os objetos $107,\;108\;e\;164$.
\

</p>

## CONSTRUINDO MODELOS PREDITIVOS PARA CLASSIFICAÇÃO DE VIDRO {.tabset .tabset-fade}

<p style="text-align: justify">

No presente trabalho utilizaremos o algoritmo de *Random Forest*, através do pacote `caret`, para poder proceder com a classificação multiclasse dos vidros. Adotaremos um número padrão de árvores (`ntree = 1500`), e todos os modelos gerados serão "cross-validados" através da técnica *k-fold*, onde $k=10$. Como nesse problema existe desbalanceamento de classes, utilizaremos também técnicas de compensação como *undersampling* e *oversampling*.
\
Deste modo, utilizando o conjunto de dados sem promover modificações (apenas removendo *outliers*), construiremos 03 modelos de classificação: 
\

* Modelo com dados originais;

* Modelo com *under*;

* Modelo com *over*.

\
Logo, para proceder com a construção dos nossos modelos de classificação, manipularemos os dados para removermos os *outliers*, separaremos nosso banco de dados em treino (`train_data`) e teste (`test_data`), na proporção de 70-30%, e criaremos o objeto `control_Cv` para poder proceder com a *cross-validation*.
\

</p>

```{r, message=FALSE, warning=FALSE}
df_pred <- df_out %>% 
  dplyr::filter(!rowid %in% c("107","108","164")) %>% 
  dplyr::select(-rowid)

df_pred_tst <- df_pred

{
  set.seed(42)
  index <- caret::createDataPartition(df_pred$Tipo, p = 0.7, list = FALSE) # particao
  train_data <- df_pred[index, ]
  test_data  <- df_pred[-index, ]

  control_Cv_orig <- caret::trainControl(method  = "cv", # cross-validation
                                         number  = 10,
                                         classProbs = T,
                                         savePredictions = T,
                                         verboseIter = FALSE)
  
  control_Cv_up <- caret::trainControl(method  = "cv", # cross-validation
                                       number  = 10,
                                       classProbs = T,
                                       savePredictions = T,
                                       verboseIter = FALSE,
                                       sampling = "up")
  
  control_Cv_down <- caret::trainControl(method  = "cv", # cross-validation
                                         number  = 10,
                                         classProbs = T,
                                         savePredictions = T,
                                         verboseIter = FALSE,
                                         sampling = "down")
  }

arvores <- 1500
```



<p style="text-align: justify">
\
Com o `df` devidamente ajustado, partiremos então para a construção dos modelos:

\

### MODELO RF SEM REAMOSTRAGEM {.tabset .tabset-fade}

* 1. 1) *Random Forest* sem reamostragem (original)

\
</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_m1 <- caret::train(Tipo ~ .,
                            data = train_data,
                            method = "rf",
                            ntree = arvores,
                            preProcess = c("scale", "center"),
                            trControl = control_Cv_orig)

cm_original_m1 <- caret::confusionMatrix(predict(model_rf_m1, test_data),                       
                                         test_data$Tipo)
cm_original_m1
```

### MODELO RF COM OVERSAMPLING {.tabset .tabset-fade}

<p style="text-align: justify">
\

* 1. 2) *Random Forest* com *oversampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_up_m1 <- caret::train(Tipo ~ .,
                               data = train_data,
                               method = "rf",
                               ntree = arvores,
                               preProcess = c("scale", "center"),
                               trControl = control_Cv_up)

cm_over_m1 <- caret::confusionMatrix(predict(model_rf_up_m1, test_data),
                                     test_data$Tipo)
cm_over_m1
```

### MODELO RF COM UNDERSAMPLING {.tabset .tabset-fade}

<p style="text-align: justify">
\

* 1. 3) *Random Forest* com *undersampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_down_m1 <- caret::train(Tipo ~ .,
                                 data = train_data,
                                 method = "rf",
                                 ntree = arvores,
                                 preProcess = c("scale", "center"),
                                 trControl = control_Cv_down)

cm_down_m1 <- caret::confusionMatrix(predict(model_rf_down_m1, test_data), 
                                     test_data$Tipo)
cm_down_m1
```

##



## TRANSFORMANDO DADOS

<p style="text-align: justify">

Apesar da robustez do algoritmo de `RF` e dos resultados satisfatórios removendo alguns objetos considerados como aberrantes, é notório que as distribuições de nossas variáveis preditoras **K**, **Mg** e **RI** apresentam elevada assimetria, e isto pode impactar negativamente o desempenho do modelo proposto.
\
Deste modo, iremos proceder com manutenção dos objetos considerados inicialmente como *outliers* e realizaremos a transformação das variáveis supracitadas através da técnica de transoformação de Yeo–Johnson. Tal fato se dá pela homogeneização da escolha do método de transformação pois algumas de nosss variáveis apresentam valor igual a 0 (zero), logo não poderemos utiliar técnica como transformação Box-Cox para todas as variáveis.
\
Abaixo, podemos visualizar que as variáveis mencionadas não apresentam visualmente padrão de distribuição normal.
\
</p>

```{r, message=FALSE, warning=FALSE}
shiny::div(plotly::ggplotly(df %>% 
                              dplyr::select(RI, K, Mg, Tipo) %>% 
                              tidyr::gather(key = "Variavel", 
                                            value = "valor", c(RI, K, Mg)) %>% 
                              ggplot2::ggplot() +
                              geom_density(aes(valor, fill = Tipo), alpha = 0.5) +
                              facet_wrap(~Variavel, scales = "free") +
                              ylab("Densidade") +
                              theme_minimal_hgrid(12), 
                            align = "center"))

shiny::div(plotly::ggplotly(df %>% 
                              dplyr::select(RI, K, Mg) %>% 
                              tidyr::gather(key = "Variavel", value = "valor") %>% 
                              ggplot2::ggplot() +
                              geom_density(aes(valor, fill = Variavel), alpha = 0.5) +
                              facet_wrap(~Variavel, scales = "free") +
                              ylab("Densidade") +
                              theme_minimal_hgrid(12), 
                            align = "center"))
```

## CONSTRUINDO NOVOS MODELOS {.tabset .tabset-fade}

<p style="text-align: justify">
Apesar dos bons valores de Acurácia, a classe **X3** não apresenta bom *score* de Verdaadeiros Positivos, logo, novos modelos serão propostos para cenários similares, tendo em vista o melhor ajuste para o modelo preditor.
\
</p>

### Cenário A

<p style="text-align: justify">
Para construir os novos modelos, precisaremos reajustar nosso `df`.
\
</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
BN_RI <- bestNormalize::bestNormalize(df$RI, allow_lambert_s = TRUE)
BN_K  <- bestNormalize::bestNormalize(df$K,  allow_lambert_s = TRUE)
BN_Mg <- bestNormalize::bestNormalize(df$Mg, allow_lambert_s = TRUE)

df_pred2 <- df %>% 
  dplyr::mutate(RI_tr = car::yjPower(df$RI, BN_RI$other_transforms$yeojohnson$lambda),
                K_tr  = car::yjPower(df$K,  BN_K$other_transforms$yeojohnson$lambda),
                Mg_tr = car::yjPower(df$Mg, BN_Mg$other_transforms$yeojohnson$lambda)) %>% 
  dplyr::select(-c(RI, K, Mg))
```

<p style="text-align: justify">
Para poder incrementar performance aos modelos propostos criaremos uma relação não linear entre os preditores e a resposta executando a regressão usando transformações dos preditores [(James et al., 2013)](https://www.ime.unicamp.br/~dias/Intoduction%20to%20Statistical%20Learning.pdf#page=160), onde iremos incluir variáveis $X^2$ no nosso modelo.
\
E, para implementar tal estratéfia, as variáveis **Fe** e **Ca** serão elevadas a potência 2, baseado na análise exploratória e o **feedback** dos modelos construídos no moemnto anterior.
\
Poderiamos pensar em algo similar para a variável **Ba**, contudo, a explicação para semelhança de medidas de tendência central em **X1** e **X3** para **Ba** se dá pela elevada quantidade de objetos com valor 0 (zero) para esta variável preditora.
\
</p>

```{r, message=FALSE, warning=FALSE}
df_pred2 <- df_pred2 %>% 
  dplyr::mutate(Fe_2 = Fe^2,
                Ca_2 = Ca^2)
```

<p style="text-align: justify">
Nossos novos modelos propostos terão configuração análoga ao primeiros modelos, com dados "originais", *undersampling* e *oversampling*.
\
</p>

```{r, message=FALSE, warning=FALSE}
{
  set.seed(42)
  index <- caret::createDataPartition(df_pred2$Tipo, p = 0.7, list = FALSE) # particao
  train_data <- df_pred2[index, ]
  test_data  <- df_pred2[-index, ]
  }
```

* 2. 1. A) *Random Forest* sem reamostragem (original)

\
</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_m2aori <- caret::train(Tipo ~ .,
                                data = train_data,
                                method = "rf",
                                ntree = arvores,
                                preProcess = c("scale", "center"),
                                trControl = control_Cv_orig)
                                               
cm_original_m2aori <- caret::confusionMatrix(predict(model_rf_m2aori, test_data),
                                             test_data$Tipo)
cm_original_m2aori
```


<p style="text-align: justify">
\

* 2. 2. A) *Random Forest* com *oversampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_up_m2aup <- caret::train(Tipo ~ .,
                                  data = train_data,
                                  method = "rf",
                                  ntree = arvores,
                                  preProcess = c("scale", "center"),
                                  trControl = control_Cv_up)

cm_over_m2aup <- caret::confusionMatrix(predict(model_rf_up_m2aup, test_data),
                                        test_data$Tipo)
cm_over_m2aup
```

<p style="text-align: justify">
\

* 2. 3. A) *Random Forest* com *undersampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_down_m2aunder <- caret::train(Tipo ~ .,
                                       data = train_data,
                                       method = "rf",
                                       ntree = arvores,
                                       preProcess = c("scale", "center"),
                                       trControl = control_Cv_down)

cm_down_m2aunder <- caret::confusionMatrix(predict(model_rf_down_m2aunder, test_data), 
                                           test_data$Tipo)
cm_down_m2aunder
```


### Cenário B

<p style="text-align: justify">
De maneira similar ao Cenário A, das "novas" variáveis, manteremos apenas a abordagem considerando as variáveis transformadas atráves do método Yeo-Johnson.
\
</p>

```{r, message=FALSE, warning=FALSE}
df_pred2 <- df %>% 
  dplyr::mutate(RI_tr = car::yjPower(df$RI, BN_RI$other_transforms$yeojohnson$lambda),
                K_tr  = car::yjPower(df$K,  BN_K$other_transforms$yeojohnson$lambda),
                Mg_tr = car::yjPower(df$Mg, BN_Mg$other_transforms$yeojohnson$lambda)) %>% 
  dplyr::select(-c(RI, K, Mg))

{
  set.seed(42)
  index <- caret::createDataPartition(df_pred2$Tipo, p = 0.7, list = FALSE) # particao
  train_data <- df_pred2[index, ]
  test_data  <- df_pred2[-index, ]
  }

```

* 2. 1. B) *Random Forest* sem reamostragem (original)

\
</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_m2bori <- caret::train(Tipo ~ .,
                                data = train_data,
                                method = "rf",
                                tree = arvores,
                                preProcess = c("scale", "center"),
                                trControl = control_Cv_orig)
                                               
cm_original_m2bori <- caret::confusionMatrix(predict(model_rf_m2bori, test_data),
                                             test_data$Tipo)
cm_original_m2bori
```


<p style="text-align: justify">
\

* 2. 2. B) *Random Forest* com *oversampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_up_m2bup <- caret::train(Tipo ~ .,
                                  data = train_data,
                                  method = "rf",
                                  ntree = arvores,
                                  preProcess = c("scale", "center"),
                                  trControl = control_Cv_up)

cm_over_m2bup <- caret::confusionMatrix(predict(model_rf_up_m2bup, test_data),
                                        test_data$Tipo)
cm_over_m2bup
```

<p style="text-align: justify">
\

* 2. 3. B) *Random Forest* com *undersampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_down_m2bunder <- caret::train(Tipo ~ .,
                                       data = train_data,
                                       method = "rf",
                                       ntree = arvores,
                                       preProcess = c("scale", "center"),
                                       trControl = control_Cv_down)

cm_down_m2bunder <- caret::confusionMatrix(predict(model_rf_down_m2bunder, test_data), 
                                           test_data$Tipo)
cm_down_m2bunder
```

### Cenário C

<p style="text-align: justify">
De maneira similar ao Cenário A, das "novas" variáveis, manteremos apenas a abordagem considerando as variáveis transformadas como $X^2$.
\
</p>


```{r, message=FALSE, warning=FALSE}
df_pred2 <- df %>% 
  dplyr::mutate(Fe_2 = Fe^2,
                Ca_2 = Ca^2)
{
  set.seed(42)
  index <- caret::createDataPartition(df_pred2$Tipo, p = 0.7, list = FALSE) # particao
  train_data <- df_pred2[index, ]
  test_data  <- df_pred2[-index, ]
  }
```

* 2. 1. C) *Random Forest* sem reamostragem (original)

\
</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_m2cori <- caret::train(Tipo ~ .,
                                data = train_data,
                                method = "rf",
                                ntree = arvores,
                                preProcess = c("scale", "center"),
                                trControl = control_Cv_orig)
                                               
cm_original_m2cori <- caret::confusionMatrix(predict(model_rf_m2cori, test_data),
                                             test_data$Tipo)
cm_original_m2cori
```


<p style="text-align: justify">
\

* 2. 2. C) *Random Forest* com *oversampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_up_m2cup <- caret::train(Tipo ~ .,
                                  data = train_data,
                                  method = "rf",
                                  ntree = arvores,
                                  preProcess = c("scale", "center"),
                                  trControl = control_Cv_up)

cm_over_m2cup <- caret::confusionMatrix(predict(model_rf_up_m2cup, test_data),
                                    test_data$Tipo)
cm_over_m2cup
```

<p style="text-align: justify">
\

* 2. 3. C) *Random Forest* com *undersampling*

\

</p>

```{r, message=FALSE, warning=FALSE}
set.seed(42)
model_rf_down_m2cunder <- caret::train(Tipo ~ .,
                                       data = train_data,
                                       method = "rf",
                                       ntree = arvores,
                                       preProcess = c("scale", "center"),
                                       trControl = control_Cv_down)

cm_down_m2cunder <- caret::confusionMatrix(predict(model_rf_down_m2cunder, test_data), 
                                           test_data$Tipo)
cm_down_m2cunder
```

##

## ANÁLISE DE PERFORMANCE

<p style="text-align: justify">

\

</p>

```{r, message=FALSE, warning=FALSE}
models <- list(original_inicial = model_rf_m1,
               original_2a = model_rf_m2aori,
               original_2b = model_rf_m2bori,
               original_3c = model_rf_m2cori,

               over_inicial = model_rf_up_m1,
               over_2a = model_rf_up_m2aup,
               over_2b = model_rf_m2bori,
               over_2c = model_rf_up_m2cup,

               under_inicial = model_rf_down_m1,
               under_2a = model_rf_down_m2aunder,
               under_2b = model_rf_down_m2bunder,
               under_2c = model_rf_down_m2cunder)

comparacao <- data.frame(Modelo = names(models),
                         Kappa  = rep(NA, length(models)),
                         Acuracia  = rep(NA, length(models)))

comparacao <- comparacao %>%
  dplyr::mutate(Acuracia = c(cm_original_m1$overall[1],
                             cm_original_m2aori$overall[1],
                             cm_original_m2bori$overall[1],
                             cm_original_m2cori$overall[1],
                                                          
                             cm_over_m1$overall[1],
                             cm_over_m2aup$overall[1],
                             cm_over_m2bup$overall[1],
                             cm_over_m2cup$overall[1],
                             
                             cm_down_m1$overall[1],
                             cm_down_m2aunder$overall[1],
                             cm_down_m2bunder$overall[1],
                             cm_down_m2cunder$overall[1]),
                
                Kappa    = c(cm_original_m1$overall[2],
                             cm_original_m2aori$overall[2],
                             cm_original_m2bori$overall[2],
                             cm_original_m2cori$overall[2],
                             
                             cm_over_m1$overall[2],
                             cm_over_m2aup$overall[2],
                             cm_over_m2bup$overall[2],
                             cm_over_m2cup$overall[2],
                             
                             cm_down_m1$overall[2],
                             cm_down_m2aunder$overall[2],
                             cm_down_m2bunder$overall[2],
                             cm_down_m2cunder$overall[2]
                             )) %>%
  reshape2::melt(id.vars = c("Modelo"))
levels(comparacao$variable) <- c("Kappa", "Acurácia")

plot_x3 <- ggplot(comparacao) +
  geom_jitter(aes(x = variable,
                  y = value,
                  fill = Modelo),
              width = 0.2, alpha = 0.7, size = 7, shape = 24) +
  facet_grid(.~variable, scales = "free") +
  # scale_y_continuous(limits = c(0, 1)) +
  labs(title = "",
       x = "Índice",
       y = "Score",
       color = "Legenda") +
  theme_bw() +
  tema +
  theme(strip.background = element_blank(),
        strip.text = element_blank())

ggsave(file = "plot_x3.png", plot_x3, width  = 11, height = 7, dpi = 700)
plot_x3
```


```{r, message=FALSE, warning=FALSE}
comparacao <- comparacao %>% 
  dplyr::filter(Modelo %in% c("over_inicial", "original_2a", "original_2b", "over_2b"))

plot_x2 <- ggplot2::ggplot(comparacao,
                (aes(x = variable,
                     y = value,
                     fill = Modelo))) +
  geom_jitter(width = 0.2, alpha = 0.7, size = 7, shape = 24) +
  scale_fill_manual(values = c(scales::hue_pal()(12)[1],
                               scales::hue_pal()(12)[2],
                               scales::hue_pal()(12)[5],
                               scales::hue_pal()(12)[8])) +
  facet_wrap(~variable, scales = "free") +
  labs(title = " ",
       x = "Índice",
       y = "Score",
       color = "Legenda") +
  theme_bw() +
  tema +
  theme(strip.background = element_blank(),
        strip.text = element_blank())
ggsave(file = "plot_x2.png", plot_x2, width  = 13, height = 9, dpi = 700)
plot_x2
```


```{r, message=FALSE, warning=FALSE}
df1 <- data.frame(cm_over_m1[["byClass"]], modelo = "cm_over_m1")
df3 <- data.frame(cm_original_m2bori[["byClass"]], modelo = "cm_original_m2bori")

plot_x1 <- df1 %>% 
  rbind(df3) %>% 
  cbind(classe = rep(paste0(rep('X', 6), setdiff(1:7, 4)), 2)) %>% 
  dplyr::select(1, 2, 7, 12, 13) %>% 
  tidyr::gather("Metrica", "Valor", -modelo, -classe) %>% 
  dplyr::mutate(Metrica = as.factor(Metrica),
                Metrica = forcats::fct_recode(Metrica, "Sensibilidade"  = "Sensitivity"),
                Metrica = forcats::fct_recode(Metrica, "Especificidade" = "Specificity"),
                
                modelo = forcats::fct_recode(modelo, "Overs. Cenário Inic." = "cm_over_m1"),
                modelo = forcats::fct_recode(modelo, "Orig. Cenário 2 - B"  = "cm_original_m2bori")) %>% 
  dplyr::rename(Modelo = "modelo") %>% 
  ggplot2::ggplot() +
  geom_jitter(aes(x = Metrica, y = Valor, fill = Modelo), 
              alpha = 0.7, size = 7, shape = 24) +
  facet_wrap(~classe, ncol = 6) +
  scale_fill_manual(values = c(scales::hue_pal()(12)[8],
                               scales::hue_pal()(12)[2])) +
  ylab("Score") + xlab("Métrica") +
  theme_bw() +
  tema +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggsave(file = "plot_x1.png", plot_x1, width  = 13, height = 7, dpi = 700)
shiny::div(plotly::ggplotly(plot_x1),
           align = "center")
```


<p style="text-align: justify">
\
Construído os modelos, foram plotados em gráficos as métricas dos doze modelos, para a comparação e seleção do de maior performance.
\
Analisando o gráfico da Figura 4, é perceptível que entre os doze modelos, quatro tiveram destaque nas métricas indicadas: original do cenário 2A, original do cenário 2B, o oversampling incial e o oversampling do cenário 2B. Sendo assim, a partir dessa análise visual, podemos selecionar apenas os quatro modelos de melhor performance para proceder com a análise. Podemos então projetar os quatro modelos selecionados entre os doze, para melhor avaliação.
\
Visualmente, é perceptível que, entre os quatro modelos, dois se destacaram: o oversampling inicial e o original de cenário 2B, possuindo valores de acurácia e Kappa bastante próximos.
Logo, não é trivial selecionar o modelo de melhor performance avaliando essas duas métricas. 
\
A fim de propor apenas um modelo preditivo, foi gerado o gráfico da Figura 6, onde a luz da exposição das métricas de sensibilidade, especificidade e F-Score, por classe, para os dois modelos, é possível ter mais propriedade acerca dos modelos construídos. 
\
Os modelos obtiveram o mesmo desempenho para as três métricas nas classes X5, X6 e X7. Contudo, na classe X3, o modelo de oversampling inicial obteve maiores valores de sensibilidade, especificidade e F-Score. 
\
Considerando que a classe X3, no geral, apresentou dificuldade em ser predita corretamente (verdadeiro positivo), o modelo escolhido para o de maior performance foi o de oversampling inicial, já que para as classes X1 e X2, temos um trade-off entre os modelos. 
\
Tal situação contempla a perspectiva inicial de difícil segregação das classes X1 e X3, como constatado na análise exploratória. É notório, também, que a abordagem com múltiplos cenários possibilita melhor compreensão sobre desempenho dos modelos para determinadas situações.
Sendo assim, feita toda a análise de métricas, o modelo de melhor performance foi o de reamostragem utilizando a técnica de oversampling, sem nenhuma potencialização ou transformação de variáveis, Cenário 1, com matriz de confusão do teste.
\
É notável o elevado número de acertos das classes X1 e X2, quando comparada as outras, justamente devido ao desbalanceamento de classes. Fica perceptível também, a dificuldade em acertar a classe X3, por ser facilmente confundida com a X1. As classes X5, X6 e X7 possuíram elevada taxa de acerto (100% para as X5 e X6). 
\
Procurando otimizar o modelo preditivo escolhido, buscou-se reduzir o número de árvores da *Random Forest* com o objetivo pontual de reduzir o custo computacional.
\
É perceptível que o erro do OOB se torna estável na média a partir da 500ª árvore de decisão, apesar de certa instabilidade das classes X1 e X2, representando que não há muito ganho para o modelo a partir daí. 
\
Sendo assim, foi modificado o número de árvores para 750 (representando metade do valor inicial), valor esse escolhido arbitrariamente com o objetivo de reduzir o custo computacional e não interferir negativamente no resultado, e o tempo de processamento para construção do modelo reduziu em 50%. 
\
Comparando os resultados com a bibliografia consultada, mais precisamente o modelo construído por Aldayel (2012), o qual obteve uma acurácia de 80,37% através de um algoritmo que combinou a decisão de dois classificadores, técnica ensemble, K-Nearest Neighbor (KNN) e Hidden Naive Bayes (HNB), o modelo construído no presente trabalho, a partir do algoritmo de Random Forest e sua posterior otimização, demonstra resultado semelhante, sendo tão potente quanto o de dois classificadores.
\

</p>

```{r, message=FALSE, warning=FALSE}
# Importancia de variaveis por Ínice Gini
gini <- varImp(model_rf_up_m1)$importance %>%
  as.data.frame() %>%
  tibble::rownames_to_column() %>%
  dplyr::arrange(Overall) %>%
  dplyr::mutate(rowname = forcats::fct_inorder(rowname)) %>% 
  ggplot2::ggplot() +
  geom_col(aes(x = rowname, 
               y = Overall, 
               fill = rowname), 
           col = "black", show.legend = F) +
  coord_flip() +
  scale_fill_grey() +
  ggtitle("Random Forest - Oversampling - Cenário Inicial") +
  xlab("Variável") + ylab("Overall") +
  theme_bw() + 
  tema
ggsave(file = "gini.png", gini, width  = 13, height = 9, dpi = 700)
shiny::div(plotly::ggplotly(gini), align = "center")


# OOB
plot_oo1 <- model_rf_up_m1$finalModel[["err.rate"]] %>% 
  as.data.frame() %>% 
  dplyr::mutate(Arvores = 1:arvores) %>% 
  tidyr::gather("Var", "Erro", -Arvores) %>% 
  dplyr::filter(Var %in% c("OOB", "X1", "X2")) %>% 
  ggplot2::ggplot() +
  geom_line(aes(x = Arvores, y = Erro, col = Var), 
            size = 1) +
  scale_color_manual(values = c("black",
                                scales::hue_pal()(6)[1],
                                scales::hue_pal()(6)[2])) +
  xlab("N° Árvores") + ylab("Erro") +
  theme_minimal_hgrid(12) + 
  theme(legend.position = "bottom") + tema
shiny::div(plotly::ggplotly(plot_oo1), align = "center")

plot_oo2 <- model_rf_up_m1$finalModel[["err.rate"]] %>% 
  as.data.frame() %>% 
  dplyr::mutate(Arvores = 1:arvores) %>% 
  tidyr::gather("Var", "Erro", -Arvores) %>% 
  dplyr::filter(Var %in% c("OOB", "X3", "X5", "X6", "X7")) %>% 
  ggplot2::ggplot() +
  geom_line(aes(x = Arvores, y = Erro, col = Var), 
            size = 1) +
  scale_color_manual(values = c("black",
                                scales::hue_pal()(6)[3],
                                scales::hue_pal()(6)[4],
                                scales::hue_pal()(6)[5],
                                scales::hue_pal()(6)[6])) +
  xlab("N° Árvores") + ylab("Erro") +
  theme_minimal_hgrid(12) + 
  theme(legend.position = "bottom") + tema

plot_oo3 <- model_rf_up_m1$finalModel[["err.rate"]] %>% 
  as.data.frame() %>% 
  dplyr::mutate(Arvores = 1:arvores) %>% 
  tidyr::gather("Var", "Erro", -Arvores) %>% 
  dplyr::filter(Var %in% c("X3", "X5", "X6", "X7")) %>% 
  ggplot2::ggplot() +
  geom_line(aes(x = Arvores, y = Erro, col = Var), 
            size = 1) +
  scale_color_manual(values = c(scales::hue_pal()(6)[3],
                                scales::hue_pal()(6)[4],
                                scales::hue_pal()(6)[5],
                                scales::hue_pal()(6)[6])) +
  xlab("N° Árvores") + ylab("Erro") +
  theme_minimal_hgrid(12) + 
  theme(legend.position = "bottom") + tema

plot_oo3 <- cowplot::plot_grid(plot_oo2, plot_oo3, align = "hv", rows = 2, axis = "bt")
cowplot::plot_grid(plot_oo1, plot_oo3, align = "hv", cols = 2, axis = "bt")


plot_oob <- model_rf_up_m1$finalModel[["err.rate"]] %>% 
  as.data.frame() %>% 
  dplyr::mutate(Arvores = 1:arvores) %>% 
  tidyr::gather("Var", "Erro", -Arvores) %>% 
  ggplot2::ggplot() +
  geom_line(aes(x = Arvores, y = Erro, col = Var), 
            size = 1) +
  scale_color_manual(values = c("black",
                                scales::hue_pal()(6)[1],
                                scales::hue_pal()(6)[2],
                                scales::hue_pal()(6)[3],
                                scales::hue_pal()(6)[4],
                                scales::hue_pal()(6)[5],
                                scales::hue_pal()(6)[6])) +
  xlab("N° Árvores") + ylab("Erro") +
  theme_minimal_hgrid(12) + 
  theme(legend.position = "bottom") + tema

ggsave(file = "plot_oob.png", plot_oob, width  = 11, height = 7, dpi = 700)
shiny::div(plotly::ggplotly(plot_oob), align = "center")
```




***

## CONSIDERAÇÕES FINAIS

<p style="text-align: justify">
\
No presente trabalho fora proposto um modelo preditivo de classificação de vidro multiclasse, utilizando do algoritmo de Random Forest para diferentes cenários e situações de treinamento, dado a condição de desbalanceamento de classes de vidro, para suporte da análise forense. 
O algoritmo mostrou-se eficiente visto que o resultado final compôs um valor de acurácia de 80,33%, ou seja, 49 de 61 observações, superior ao modelo original. 
\
Como indicado por Breiman (2001), o algoritmo de Random Forest é robusto para ruídos e problemas não-lineares, e apesar da remoção de alguns objetos com valores aberrantes porém no cenário inicial proposto, sem transformação ou adição de variáveis incrementadoras de performance, o algoritmo apresentou melhor resultado. 
\
Vale a pena ressaltar, também, a importância das técnicas de reamostragem para construção de modelos preditivos em condições de desbalanceamento de classes, haja visto que o modelo proposto no presente artigo foi concebido utilizando a técnica de oversampling.
\
Como sugestão para trabalhos futuros, indicamos a aplicação de técnica de modelos de misturas, tendo em vista as possíveis sub-populações de distribuição dos atributos. Sugerimos também tentativa de técnicas mais robustas para detecção de outliers, como a PCA (Análise de Componentes Principais), e, para a construção de modelo com maior acurácia, a tentativa de emprego de método de super learning poderá proporcionar melhor performance.
aior opacidade.
\
</p>


***

\

**Discentes:**
\
**[Brenner Silva](http://lattes.cnpq.br/8005291514473676)**;
\
**[Marcello Pessoa](http://lattes.cnpq.br/)**.

\
**Docente:**
\
**[Karla Esquerre](http://lattes.cnpq.br/1956096628005272)**.

\

[<img src="http://gamma.ufba.br/images/logoRStudio.png" height="300px" width="1005px" />](http://gamma.ufba.br/)
***
\

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>


